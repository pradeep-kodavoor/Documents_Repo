Algorithms - Steps to be performed for accomplishing a particular task.
Real time example: Steps involved in Preparing Tea.

Need for Big O Notation:

Same implementation can take different time when it is run on Super Computer and Normal Computer.
Hence for determing performance based on number of steps Big O Notation was introduced, where performance is measured by taking 
number of steps into account.

Big O Notation -
Determines performance of the data structures
Describes the complexity of the data structure
Tells us how well an algorithm scales as the input increases.
Worst case is used to determine the time complexity of the algorithm.

O(1) - Constant time - No matter how many elements u have in your data structures, Algorithm always perform same number of operations
O(logn)(base 2) - Logarithamic - Slows rises as the number of elements increases Ex: Binary Search
O(n) - Linear - Descreases the performance as the elements decreases. Ex: For Loop, While Loop
O(nlogn)(base 2) - n log-star-n Logarithamic - Slows rises as the number of elements increases Ex: Binary Search
O(n^2) - Quadratic - As the number of elements increase, performance becomes very very low. Ex: Loop within loop
O(c^n) - Exponential - Recusrive calls over n and loop over c in it.
O(n!) - Factorial - Looping over n and recursive call in the loop for (n-1) elements

Sort Algorithms:

Bubble Sort 
  - Performance degrades quickly as number of elements grows.
  - Grows the sorted partition from right to left
Algorithm:
  - Larger value in an array bubbles up to the top on each iteration.
  - During each iteration, an element is compared with the next one and swaped if an element is greater than the next one.
  - End of each iteration an element would be in correct position

Performance:
  - In-place algorithm, logical partition of array is done. Extra memory is not required for partition.
  - O(n^2) - Quadratic - Time Complexity
  - It will take 100 steps to sort 10 elements, 10,000 steps to sort 100 elements so on..
  - Algorithm degrades quickly as number of elements increases.
  - Stable Algorithm.

Stable vs Unstable Algorithm
  - Stable: Preserves relative ordering of duplicate items
    Ex: If an array has 2 elements with value, its ordering is unaltered.
  - Unstable: Does not preserve relative ordering of duplicate items
    Ex: If an array has 2 elements with value, its ordering is changed.

Selection Sort
  - Divides the array into sorted and unsorted partition
  - Grows the sorted partition from right to left
  - Traverse the elements of Unsorted partition and find the largest element
  - Swap the largest element with the last element

Performance:
  - In-place algorithm, logical partition of array is done. Extra memory is not required for partition.
  - O(n^2) - Quadratic - Time Complexity
  - It will take 100 steps to sort 10 elements, 10,000 steps to sort 100 elements so on..
  - Algorithm degrades quickly as number of elements increases.
  - Unstable Algorithm.
  
 Insertion Sort
  - Divides the array into sorted and unsorted partition
  - Grows the sorted partition from left to right
  - Starts by considering element at position 1 as element in sorted partition.
  - On Each iteration, first element from unsorted partition is taken and inserted into sorted partition.
  - We compare the value to be inserted with values in the sorted partition.
  - Position of insertion is determined by comparing values in the sorted partition against new element.
  - If new element is less than the elements in the sorted partition, elements are shifted in the sorted partition.

Performance:
  - In-place algorithm, logical partition of array is done. Extra memory is not required for partition.
  - O(n^2) - Quadratic - Time Complexity
  - It will take 100 steps to sort 10 elements, 10,000 steps to sort 100 elements so on..
  - Algorithm degrades quickly as number of elements increases.
  - Unstable Algorithm.
  
Shell Sort
  - Variation of Insertion Sort
  - Insertion chooses which element to insert using a gap of 1
  - Shell sort starts out using larger gap value
  - As the alogorithm progresses, gap value is reduced
  - Last gap value is 1, at this point it is equivalent to insertion sort 
  - Algorithm does preliminary works using gap value greater than 1 and then it performs insertion sort
  - By the time we get to insertion sort array would be partialy sorted hence it takes less time.
  
Performance:
  - In-place algorithm, logical partition of array is done. Extra memory is not required for partition.
  - Time Complexity - Depends on the gap choosen. Worst case - O(n^2)
  - It requires less shifting
  - Unstable algorithm
  
