Uses of Stream API

Helps using data in a declarative way. We can use functions like max min without iterating completetly.
Pipelines of data operations can be executed in parallel or in sequence.
Support for group by, order by operations etc
Functional Programming
Paralle processing of data

Intermediate vs Terminal Operation

New Features of JAVA 8
  - Lambda Expression
  - Functional Interface
  - Interface with static and default method
  - Optional
  - Stream API
  - Uses of Stream API
  - Date and Time API
  - Base64 Encoding and Decoding
  - NashHorn JavaScript Engine - fast processing
  - Collections API Enhancement
  - Concurrency Enhancement
  - Fork/Join Framework Enhancement
  - Spliterator
  - Internal Iteration
  - Type and Repeatable Annotation
  - Method Parameter Reflection

Benefits of new features of JAVA 8
  - Support for functional programming using lambda and streams
  - Ease of processing high volume of data using streams. Ex: MapReduce
  - Ease of use by getting Parameter names through Reflection API
  - With enhanced collection API, we can have the reusable code with new kinds of Iterators
  - Smart Exception handling with optional. No need of handling Null Pointer Exception
  - Control on JVM with new parameters
  - Encryption support with Base64 
  - Faster execution with NashHorn JavaScript support
  
Lambda Expression in JAVA 8
  - It is an annonymous function. Function without a name
  - It is a method that doesn't need access modifiers, name or return type declaration. 
  - It accepts set of input parameters and returns result.
  Ex: Below expression takes stream of input as input and prints each element to console
  Arrays.asList("A","B","C").forEach(element->System.out.println(element))
  
  - 3 parts of Lambda
    + Parameter List - (element) -  Can have zero or more parameters
    + Lambda Arrow operator - (->) - Separates Parameter list and body
    + Body - (System.out.println(element)) - Piece of code that we are supposed to execute. Braces are optional

  - Return Type of Lambda Expression is a Functional interface. Most of the time java.lang.Runnable Interface.
  
Reasons of Java 8 Release
  - Functional Programming
    + Main theme of Java 8 is support for functional programming
  - Cloud computing
    + Lambda Expression is very usefull in Cloud computing
    + We can pass code as data and we can run the same code on multiple servers
  - Big Data
    + With increase in Database size and growth of multi-code CPU servers, there is need for Java to support these large scale systems
    + Support of streams helps in this case
  - Optional
    + Best practise borrowed from Google's Guava Library for handling exceptional cases
    + This has made programs more robust with support for edge cases

Advantages of Lambda Expression
  - Useful for passing code as a data in a method
  - We can pass method as a parameter
  
Functional Interface in Java 8
  - Interface with only one abstract method.
  - It can have default methods with implementation
  - A default method is not abstract
  Ex: Runnable, Callable
 
Single Method Abstract(SAM) in Java 8
  - Other name of fuctional interface
  - Interface with one functional interface

Defining a functional interface in Java 8
  - Create a interface and write one abstract method in it
  - Annotate the interface with @FunctionalInterface annotation

Why do we need Functional Interface?
  - Functional Interfaces are mainly used lambda expression, method references and constructor references
  - Code can be treated as data
  - Piece of code can be passed as argument
  - Serves as data type for lambda expression
  - Method implemented by functional interface is passed as a code to a method

Is it mandatory to mark Functional Interface with @FunctionalInterface annotation?
  - Not mandatory
  - But if we annotate a interface which has more than 1 abstract methods with @FunctionalInterface, compiler will throw an error.

Difference between Collection and Stream API
  - Version
    + Collection API is used since Java 1.0
    + Stream is recently introduced in Java 1.8
  - Usage
    + Collection API is used for storing data in different kinds of Data Structures. Ex: List ,Set
    + Stream API is used for computation of data on large of set of objects
  - Finite
    + Collection API is used for storing finite number of elements. Ex: List of students
    + Stream API can handle stream of data, that contains infinite number of elements. Ex: Log files
  - Eager vs Lazy
    + Collection API constructs objects in eager manner
    + Stream API constructs objects in lazy manner
  - Multiple consumption
    + Most of the collection supports iteration and consumption of elements multiple times
    + Stream API can consume/iterate elements only once
    
Uses of Stream API
  - Helps in using data in a declarative way
  - We can make use of database functions like max() min()
  - It makes use of multicore architecture without worrying about multi threading code
  - We can create pipeline of Data operations with Java Stream that can run in a sequence or parallel. Ex: Data warehousing
  - It supports group by, order by operations
  - We can write the code in Functional Programming style
  - Supports parallel processing of data

Difference Intermediate and Terminal Operations
  - Evaluation
    + IO is not evalualated until we chain it with a terminal operation
    + IO is done at intermediate state
    + TO can be evaluated independently
    + TO is the last opertion
  - Output
    + Output of IO is another stream of data
    + Output of TO opertion is not a stream
  - Lazy Evaluation
    + IO are evaluated in lazy manner
    + TO are evaluated in eager manner
  - Chaining
    + Multiple IO can be chained
    + TO can be changed multiple times
  - Multiple
    + IO can be mulitple in stream processing
    + TO can be used only once in stream processing
    
Spliterator in Java 8
  - It is iterator used to traverse and partition elements of a source
  - We can traverse elements sequentialy and individualy in bulk
  - Source can be IO Channel OR Collection or Generator Function

Difference between Iterator and Spliterator
  - Usage
    + Spliterator can be used with Streams
    + Iterators can be used only with Collection objects
  - Iteration
    + Spliterator uses Internal Iteration
    + Spliterator can iterate streams in parallel/sequential manner
    + Iterator uses External Iteration
    + Iterator can only iterate in sequential manner
  - Traverse
    + Spliterator can traverse elements in bulk/individualy
    + Iterator can only traverse elements  individualy
  - 
