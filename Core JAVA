Java Source File:
    - A source file can have any number of classes.But it can have max 1 public class.
    - If there are there more than one public class, Compiler asks us to declare the class in separate file.
    - If there is no pubic class, Any name can be used as Source File name.
    - A source file can have any number of main methods. For running any class it is mandatory to have main 
    method with JVM supported format
    
Compiling and Running Java Source Code with package declaration:
    - Full Directory Path has to be sepecified while compiling
    - D:\Users\734456\workspace\Core-Java-Practise\src\main\java>javac -d . T.java
    - Command create folders with package name in the current working directory
    - Fully Qualified class name has to be specified while running a class.
    - D:\Users\734456\workspace\Core-Java-Practise\src\main\java>java com.practice.sample.T

Import Statements:
    - Explicit Import : import java.util.ArrayList;
    - Implicit Import : import java.util.*;
    - Explicit import is always recommended since it improves readbility.
    - Implicit import statement will only import all classes present in the current package. Classes in the sub package are 
     not imported.
    - Ex: java.util.regex.Pattern will be imported by using import java.util.regex.*
    - import java.util.* will not import Patternn class.

Classes and Interfaces present in java.lang imported automatically. Ex: Thread, Exception.
All classes present in current working directory is available by default. No need of importing it.

Package : 
    - Encapsulation mechanism to group of related classes and interfaces to a single unit.
    - In any JAVA Source file atmost one package declaration is allowed.
    - Package declaration should be first statement in the source file always.

Order for JAVA Source file
    - package declaration
    - import statment
    - ass/interface/enums

Advantages: 
    - Naming conflicts
    - Modularity
    - Maintainability
    - Security

Class Level Access Modifiers - Provides information about the behavior of the class to JVM

Modifier applicable for top level class
public - class can be accessed by anywhere.
default - class can be accessed only within the package.


abstract - applicable for classes and methods
If a class has atleast one abstract method, it has to be declared abstract.

final - 
strictfp - 

Modifier applicable for inner class in addition to above modifiers
private -
protected - 
static




 Access Modifiers
   Class  - default: Accessible only inside the package, public: Visible everywhere
   Methods - public: Accessible everywhere, protected: Can only be used either in same package or sub-class
             private: Only available inside the class, default: Only available inside the package
             
   Protected Access Modifier:
         Members can be accessed throughout the package.
         In different package, 
              members can be accessed directly or by creating object and reference of sub class.
              members cannot be accessed by creating object and reference of super class.   
   
 Non-Access Modifiers
   final
      - Class cannot be extended 
      - Method cannot be overriden 
      - Variable value cannot be changed once it is assigned
      - Varibae value can be assigned only once if it is not initialized
   static
      - Variable are present at Class level
      - Single instance is available and shared accross all the objects
      - Methods cannot access instance variables or methods . But Instance methods can access static variables and methods
      - Methods can only access Static Methods and variables.
  
  Declaring constants : public static final int PI = 3.14;
    
JVM Memory Model:

Heap Area : Memory is allocated for Objects and arrays. Created when JVM starts.
Method Area : Methods and fields are stored. 
JVM Stacks: Local variable and partial results are stored. Stack frame is created for each thread.
Native Method Stacks: Supports native methods

Heap Memory : 

Heap Memory - Will store the objects
Stack Memory - Will store the variables

Primitive variable - will have variable values
Reference variable - will have reference to the memory location

Comparison of reference variable compares its memory location not the values of instance variables.

String - Immutable
Once created, value cannot be changed in the memory location.

Creating Immutable Class in JAVA
  - Class should be declared as final, so that no other class can extend it.
  - All variables of the class should be declared private, so that it cannot be accessed outside.
  - There should not be any setter methods for modifying the variable values.
  - Perform deep cloning of all reference variables(If class has reference variable do not assign it directly, 
  instead extract the values of the reference variable and create a new Object).

Variable Arguments. Takes any number inputs to a method. Introduced in JDK 5
Syntax : sum (int... marks) 
Sample method call: sum(2,3) sum(2,3,5)

Variable argument should always be last arugment inside a method.
Ex: sum(int length,int... num ) - Correct
Ex: sum(int... num, int length) - Wrong

Arrays:
int[] intArray = new int[5];
intArray = {1,2,3};
int[] newArray = {5,6,7}

Object Oriented Programming

Composition : Has-a relationship. Ex: Person has a Adress, Book has a Review, 
Inheritance : Is-a relationship. Ex: Student is a Person, Ferrari is a Car. 
Sub-class inherits all the state and behavior of the parent class.

Method Overriding - Overriding the implementation provided in the super class with new implementation.

super - Keyword to access state and behavior of parent class
this - keyword to access state and behavior of current class

MultiThreading

2 wasy of creating thread
 - Extend Thread class
 - Implement Runnable Interface and pass the object to Thread class constructor
 
join() and sleep() methods of Thread class throws InterruptedException - Checked Exception.
It has to be handled whenever these methods are used

wait() method of Object class also throws InterruptedException - Checked Exception.

Executor Service - For creating multiple threads in a simpler ways and manage the size of thread pool
execute() - For invoking a normal task

Callable Thread - task which returns some value
submit(Callable task) -> Executes single callable task
invokeAll(Collection of Callable tasks) -> Executes multiple callable task at a time

Exception Handling

Finally block - 
 - Executes even if exception is raised
 - Even if return statement is present
 - Will not be executed if lines inside finally throws exception
 - If JVM crashes (System.exit(0)) - DO NOT TRY

2 types of Exceptions
- Sub-classes of Runtime Exceptions
- Not a Sub-class of Runtime Exceptions (All classes that extends Exceptions and not Runtime Exceptions)

class Error extends Throwable

class Exception extends Throwable
class InterruptedException extends Exception 
 - Checked Exception 
 - Any class that extends Exception 
 - Should be handled always by throwing or surrounding by try/catch 

class RuntimeException extends Exception
class NullPointerException extends RuntimeException 
 - Un-Checked Exception 
 - Any class that extends Runtime Exception
 - Not mandatory of handling the exception
 
 Functional Programming
 
 Stream - source of objects 
 
 2 Operations on stream
  - Intermediate operation - 
    Input -> Stream
    Output -> Stream
    Ex: filter(), sorted(), distinct() 
    Stream can have multiple Intermediate Operations
    
  - Terminal operation 
    Input -> Stream  
    Single output 
    Ex: min(), max(), forEach(), reduce(), collect()
    
 Concurrent Collection
   Concurrent collections provide Thread safe without significant performance impact in specific scenarios.
 Concurrent HashMap 
   Complete HashMap is not locked, instead few regions are locked, thus improved performance and thread safe.
   
 CopyOnWriteArrayList
    Should be used when there more read operation than write.
  

   
Nested Class
    - Default Nested Class - Requires outer class reference for instantiating. InnerClass innerClass = nestedClassRunner.new InnerClass();
    - Static Nested Class - Can be instantiated directly. StaticNestedClass staticNestedClass = new StaticNestedClass();

Anonymous class 
   - Inner class without a name. 
   - Can be created by implementing an Interface or by extending a Class
 

Serialization - Used of for storing the state of object in the disk or transferring over network.
Class has to implement Serializable Marker Interface for allowing serilization of instances of the class.

serialVersionUID 
    - JVM generates by default based on the members of the class.
    - Changes everytime when members are modified.
    - Used during serialization and de-serialization as unique identifier of the class.

Issues with JVM generated serialVersionUID
    - Creates issues during De-serialization if there in a modification to the existing members of the class
    - Throws an InvalidClassException, since SerialVersionUID changes on modification of existing members. 
      Hence JVM treats it as a different class

Declaring serialVersionUID
    - If we declare serialVersionUID in our class, same would be used during serialization and de-serialization.
    - Thus, even if we modify the members of the class serialVersionUID remains same. Hence JVM identifies class as 
      new version of the existing class

JIT Compiler Internal Implementation

Overloading Overriding

Marker Interface

AutoCloseable Interface
For Try with Resources implementation, Classes should implement AutoCloseable Interface.



